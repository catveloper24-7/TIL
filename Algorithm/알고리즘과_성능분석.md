# 알고리즘과 성능 분석

## 1. 알고리즘 (Algorithm)

### 1.1 알고리즘 기본 개념
* 데이터 : 컴퓨터가 처리해야 될 대상
* 컴퓨터 : **데이터를 처리**하여 정보를 생성하는 기계 → **문제를 해결**하여 정보를 생성하는 기계
* 알고리즘 : 문제를 해결하기 위해 논리적으로 기술해 놓은 일련의 명령문
* 프로그램 : 알고리즘을 컴퓨터가 이해하고 실행할 수 있는 특정 프로그래밍 언어로 표현한 것

### 1.2 알고리즘 기술 (Algorithm Description)

#### 1.2.1 알고리즘 기술 언어
문제 해결을 위해선 해결 방법을 정형화하여 명령문 형태로 정확히 기술하는 것이 중요하기 때문에, 프로그래밍 언어보다 사람이 이해하기 쉽고 체계적 표현이 가능한 중간 형태의 언어를 사용하는 것이 좋다. 이를 위해 정의한 언어를 **ADL(Algorithm Description Language)**이라 하고, 이런 ADL 과 자연어를 혼용해서 표현한 것을 **의사코드(pseudo code)**라고 한다.
  * 사람이 이해하기 쉽다.
  * 다른 프로그래밍 언어로 변환하기 쉽다.

#### 1.2.2 알고리즘 요건
1. 알고리즘은 수행해야 될 작업 내용과 순서가 명령문으로 완전하고 명확하게 명세되어야한다. 
   * 순수하게 알고리즘이 지시하는 그대로 실행했을 때 의도한 결과가 얻어져야한다.
2. 알고리즘은 외/내부의 입력이 주어지면 실행 결과로 하나 이상의 출력을 생성해야한다.
3. 알고리즘은 실행 뒤에 반드시 종료되어야한다. → 반드시 결과를 생성해야 된다.

## 2. 프로그램 성능 분석 (program performance evaluation)

### 2.1 프로그램 성능 평가 방법
동일한 작업을 수행하는 여러 프로그램이 있을 때, **가능한 한 적은 메모리 공간과 적은 실행 시간을 필요로 하는 프로그램이 더 효율적**일 것이다. <br>
이처럼 어느 프로그램(알고리즘)이 보다 좋은 지를 객관적으로 비교하기 위하여 프로그램의 성능 평가가 필요하고, 다음 2가지 방법으로 평가를 한다.
* 성능 분석 (performance analysis) : 프로그램을 실행하는데 필요한 시간과 공간을 **추정**하는 것
  * 보통 개발 전에 실행
    * 어떤 알고리즘으로 개발하는 것이 더 좋을 지 결정하기 위해
* 성능 측정 (performance measurement) : 컴퓨터가 실제로 프로그램을 실행하는데 걸리는 시간을 **측정**하는 것
  * 보통 개발 후에 실행

### 2.2 성능 분석

#### 2.2.1 성능 분석 종류
공간 복잡도와 시간 복잡도 모두 정확한 실제 값이 아니라 추정한 값이다.<br>
옛날에 비해 컴퓨터의 메모리가 크게 증가되었기 때문에 공간 복잡도보다는 시간 복잡도가 더 중요하게 여겨지고 있다.

1. 공간 복잡도 (space complexity) <br>
   프로그램을 실행시켜 완료하는데 필요한 총 저장 공간(메모리의 크기)을 의미하며, 고정공간과 가변 공간의 합으로 나타낸다.

$$S_p = S_c + S_e$$
* $S_p$ : 프로그램이 필요로 하는 총 저장 공간
* $S_c$ : 고정 공간
  * 프로그램 크기나 입출력 횟수와 관계없이 고정적으로 필요한 저장 공간
  * 컴파일된 프로그램 명령어 공간, 변수, 상수들을 위한 저장 공간이 포함된다.
* $S_e$ : 가변 공간
  * 실행 과정에서 데이터 구조와 변수들이 필요로하는 저장 공간이 포함된다.
  * 함수 순환 호출 시 필요한 런타임 스택(runtime stack)저장공간도 포함된다. 

  보통 공간 복잡도 분석 시에는 가변 공간에 대해 더 중점을 두며, 보다 적은 공간 복잡도를 가진 프로그램이 더 성능이 좋다고 볼 수 있다.

2. 시간 복잡도 (time complexity) <br>
   프로그램을 실행시켜 완료하는데 걸리는 시간을 의미한다. 실행 속도라고도 볼 수 있다.

$$T_p = T_c + T_e$$
* $T_p$ : 프로그램을 실행하는데 필요한 시간
* $T_c$ : 컴파일 시간
* $T_e$ : 실행 시간

  컴파일 시간은 고정적이기 때문에, 시간 복잡도를 비교할 때는 실제 실행 시간만 고려하면 된다.

    * 변수 선언, 조건문 등과 달리 반복문의 경우 입력의 크기가 커지면 커질수록 실행 시간에 많은 영향을 끼치기 때문에,  반복문이 시간 복잡도의 가장 중요한 요소이다.

#### 2.2.2 시간복잡도 표기법
시간복잡도를 표현하기 위한 점근적 표기법으로는 $O, Ω, Θ$ 3가지 표기법이 있으며, 프로그램을 세그먼트별로 계산한 후 합산하는 세그먼트 점근적 복잡도 계산 방식을 사용한다.
* 모든 명령문의 실행 단계 수를 정확하게 계산하지않고 세그먼트별로 계산을 한다.
* 일반 덧셈과 달리 제일 큰 크기의 항이 결과가 된다.

##### 2.2.2.1 Big-oh($O$) 빅-오 표기법 : $O(n)$
가장 많이/보편적으로 사용하는 표기법으로, **알고리즘의 최악의 실행 시간**을 표기한다. 
* **아무리 최악의 상황이라도, 이 정도의 성능은 보장한다**는 의미이다.
* 입력 n에 따라 시간 복잡도가 결정되며, 가장 큰 영향을 미치는 n의 단위로 표기한다.
  * n이 작은 경우에는 상수가 중요한 영향을 끼치지만, n이 커질수록 상수는 영향을 끼치지않는다.
* Big-oh($O$) 표기법으로 표시되는 연산 시간은 다음과 같은 그룹으로 나눌 수 있으며 각각 별도의 이름이 있다.<br>
  $O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!)$
    * $O(1)$ : 상수 시간 (constant time)
    * $O(logn)$ : 로그 시간 (logarithmic time)
    * $O(n)$ : 선형 시간 (linear time)
    * $O(nlogn)$ : n로그 시간(n$logn$ time)
    * $O(n^2)$ : 평방 시간 (quadratic time)
    * $O(n^3)$ : 입방 시간 (cubic time)
      * $k >= 1$에 대하여 $O(n^k)$을 다항식 시간 (polynomial time)이라고도 한다.
    * $O(2^n)$ : 지수 시간 (exponential time)
    * $O(n!)$ : 계승 시간 (factorial time)

> [수학적 정의]<br>
> f와 g를 각각 양의 정수를 갖는 함수라 할 때, 어떤 두 양의 상수 a와 b가 존재하고 모든 $n≥b$에 대하여, $f(n)≤a*g(n)$이면 $f(n)=O(g(n))$이다.<br>
> * $f(n)=O(g(n))$이면, n이 계속적으로 무한히 커질 때 $f(n)$의 값은 결국 $g(n)$의 **상한**으로 점점 가깝게 점근적으로 한정되기 때문에, $g(n)$을 $f(n)$의 어림값으로 볼 수 있다는 의미이다.
>   * 상한 : 집합의 값이 아무리 커도 마지막 이 값을 넘지 못하면 이 값을 상한이라 한다.
> * Big-oh($O$)를 **점근식 표기법**(asymptotic notation)이라 한다.

##### 2.2.2.2 Big-omega($Ω$) 빅-오메가 표기법 : $Ω(n)$
오메가 표기법은 알고리즘의 **최상**의 실행 시간을 표기한다.

> [수학적 정의]<br>
> f와 g를 각각 양의 정수를 갖는 함수라 할 때, 어떤 두 양의 상수 a와 b가 존재하고 모든 $n≥b$에 대하여, $f(n)≥a*g(n)$이면 $f(n)=Ω(g(n))$이다.<br>
> * $f(n)=Ω(g(n))$이면, n이 계속적으로 무한히 커질 때 $f(n)$의 값은 결국 $g(n)$의 **하한**으로 점점 가깝게 점근적으로 한정된다는 의미이다.

##### 2.2.2.3 Big-theta($Θ$) 빅-세타 표기법 : $Θ(n)$
세타 표기법은 알고리즘의 **평균** 실행 시간을 표기한다.

> [수학적 정의]<br>
> f와 g를 각각 양의 정수를 갖는 함수라 할 때, 어떤 세 양의 상수 a,b,c가 존재하고 모든 $n≥c$에 대하여, $a*g(n)≤f(n)≤b*g(n)$이면 $f(n)=Θ(g(n))$이다.<br>
> * $f(n)=Θ(g(n))$이면, $f(n)$은 $g(n)$을 상한과 하한으로 하여 점근적으로 한정된다는 의미이기때문에, Big-oh나 Big-omega 표기법보다 훨씬 정밀하다.

## 참고(Reference)
* [(강의) 패스트캠퍼스 - 한 번에 끝내는 코딩테스트 369 Java편 초격차 패키지 Online](https://fastcampus.co.kr/dev_online_codingtest)
* [(기술 서적) 자료구조와 JAVA - 저자 이석호 / 출판사 정익사](http://jungiksa.co.kr/21/?q=YToxOntzOjEyOiJrZXl3b3JkX3R5cGUiO3M6MzoiYWxsIjt9&bmode=view&idx=41741&t=board)